/*
 * Copyright (c) Microsoft. All rights reserved.
 * Licensed under the MIT license. See LICENSE file in the project root for full license information.
 */

package samples.com.microsoft.azure.sdk.iot;

import com.azure.core.credential.AzureSasCredential;
import com.microsoft.azure.sdk.iot.deps.serializer.ErrorCodeDescription;
import com.microsoft.azure.sdk.iot.service.Device;
import com.microsoft.azure.sdk.iot.service.FeedbackBatch;
import com.microsoft.azure.sdk.iot.service.FeedbackReceiver;
import com.microsoft.azure.sdk.iot.service.FeedbackRecord;
import com.microsoft.azure.sdk.iot.service.FileUploadNotification;
import com.microsoft.azure.sdk.iot.service.FileUploadNotificationReceiver;
import com.microsoft.azure.sdk.iot.service.IotHubServiceClientProtocol;
import com.microsoft.azure.sdk.iot.service.Message;
import com.microsoft.azure.sdk.iot.service.RegistryManager;
import com.microsoft.azure.sdk.iot.service.RegistryManagerOptions;
import com.microsoft.azure.sdk.iot.service.ServiceClient;
import com.microsoft.azure.sdk.iot.service.ServiceClientOptions;
import com.microsoft.azure.sdk.iot.service.auth.AuthenticationType;
import com.microsoft.azure.sdk.iot.service.devicetwin.DeviceMethod;
import com.microsoft.azure.sdk.iot.service.devicetwin.DeviceMethodClientOptions;
import com.microsoft.azure.sdk.iot.service.devicetwin.DeviceTwin;
import com.microsoft.azure.sdk.iot.service.devicetwin.DeviceTwinClientOptions;
import com.microsoft.azure.sdk.iot.service.devicetwin.DeviceTwinDevice;
import com.microsoft.azure.sdk.iot.service.devicetwin.Query;
import com.microsoft.azure.sdk.iot.service.devicetwin.SqlQuery;
import com.microsoft.azure.sdk.iot.service.exceptions.IotHubException;
import com.microsoft.azure.sdk.iot.service.jobs.JobClient;
import com.microsoft.azure.sdk.iot.service.jobs.JobClientOptions;
import com.microsoft.azure.sdk.iot.service.jobs.JobResult;
import lombok.extern.slf4j.Slf4j;

import javax.crypto.Mac;
import javax.crypto.spec.SecretKeySpec;
import java.io.IOException;
import java.io.UnsupportedEncodingException;
import java.net.URLEncoder;
import java.nio.charset.Charset;
import java.nio.charset.StandardCharsets;
import java.security.InvalidKeyException;
import java.security.NoSuchAlgorithmException;
import java.time.Instant;
import java.util.Base64;
import java.util.UUID;

/**
 * Sample that demonstrates how to use the {@link AzureSasCredential} authentication mechanism when using the service clients.
 * This sample also provides a helper function that demonstrates how to generate shared access signatures that can be
 * used to create instances of {@link AzureSasCredential}.
 */
@Slf4j
public class AzureSasCredentialSample
{
    public static void main(String[] args)
    {
        SamplesArguments parsedArguments = new SamplesArguments(args);

        String sharedAccessSignature = parsedArguments.getSharedAccessSignature();

        // Shared access signatures can be generated by the SDK for you by using the service client constructors
        // that take in your IoT Hub's connection string. This sample will demonstrate how to construct service clients
        // without giving them the connection string by giving them shared access signatures instead.

        // This sample includes a helper function that shows how to build shared access signatures below.
        // Search for "generateSharedAccessSignature"
        //
        // More details on how to build this shared access signature can be found here:
        // https://docs.microsoft.com/en-us/azure/iot-hub/iot-hub-devguide-security#security-token-structure
        AzureSasCredential credential = new AzureSasCredential(sharedAccessSignature);

        // "my-azure-iot-hub.azure-devices.net" for example
        String iotHubHostName = parsedArguments.getIotHubHostName();

        String newDeviceId = runRegistryManagerSample(iotHubHostName, credential);

        runTwinClientSample(iotHubHostName, credential, newDeviceId);

        runServiceClientSample(iotHubHostName, credential, newDeviceId);

        // The AzureSasCredential object supports updating the shared access signature which is important to do
        // once the previous signature has expired, or is close to expiring. This sample assumes that no renewal will
        // be necessary since the sample completes in a few seconds. After updating the credential object, any
        // clients that were constructed with that credential will start using the updated signature

        //String updatedSignature = "some new shared access signature";
        //credential.update(updatedSignature);

        runJobClientSample(iotHubHostName, credential);

        runDeviceMethodClientSample(iotHubHostName, credential, newDeviceId);
    }

    /**
     * Create a shared access signature for a given resource and key. This method isn't used by the sample,
     * but it is a good reference for how to create shared access signatures in Java.
     *
     * @param resourceUri The resource that the shared access token should grant access to. For cases where the token
     * will be used for more than one function (i.e. used by registryManager to create a device and used by serviceClient
     * to send cloud to device messages), this value should be the hostName of your IoT Hub
     * ("my-azure-iot-hub.azure-devices.net" for example). Shared access signatures do support scoping of the resource
     * authorization by making this resourceUri more specific. For example, a resourceUri of "my-azure-iot-hub.azure-devices.net/devices"
     * will make this token only usable when creating/updating/deleting device identities.
     * For more examples, see <a href="https://docs.microsoft.com/en-us/azure/iot-hub/iot-hub-devguide-security#use-security-tokens-from-service-components">Using security tokens from service components</a>
     * @param key The shared access key for your IoT Hub.
     * @return The shared access signature. This value can be used as is to build a {@link AzureSasCredential} instance
     * @throws UnsupportedEncodingException If UTF_8 is not a supported encoding on your device.
     * @throws NoSuchAlgorithmException If HmacSHA256 algorithm isn't found.
     * @throws InvalidKeyException If initializing the HmacSHA256 SHA fails.
     * @see <a href="docs.microsoft.com/en-us/azure/iot-hub/iot-hub-devguide-security">Control access to IoT Hub</a>
     */
    @SuppressWarnings("unused")
    public static String generateSharedAccessSignature(String resourceUri, String key)
        throws UnsupportedEncodingException, NoSuchAlgorithmException, InvalidKeyException
    {
        Charset utf8 = StandardCharsets.UTF_8;

        // Token will expire in one hour
        long expiry = Instant.now().getEpochSecond() + 3600;

        String stringToSign = URLEncoder.encode(resourceUri, utf8.name()) + "\n" + expiry;
        byte[] decodedKey = Base64.getDecoder().decode(key);

        Mac sha256HMAC = Mac.getInstance("HmacSHA256");
        SecretKeySpec secretKey = new SecretKeySpec(decodedKey, "HmacSHA256");
        sha256HMAC.init(secretKey);
        Base64.Encoder encoder = Base64.getEncoder();

        String signature = new String(encoder.encode(
            sha256HMAC.doFinal(stringToSign.getBytes(utf8))), utf8);

        String token = "SharedAccessSignature sr=" + URLEncoder.encode(resourceUri, utf8.name())
            + "&sig=" + URLEncoder.encode(signature, utf8.name()) + "&se=" + expiry;

        return token;
    }

    private static String runRegistryManagerSample(String iotHubHostName, AzureSasCredential credential)
    {
        // RegistryManager has some configurable options for HTTP read and connect timeouts, as well as for setting proxies.
        // For this sample, the default options will be used though.
        RegistryManagerOptions options = RegistryManagerOptions.builder().build();

        // This constructor takes in your implementation of AzureSasCredential which allows you to use symmetric key based
        // authentication without giving the client your connection string.
        RegistryManager registryManager = new RegistryManager(iotHubHostName, credential, options);

        String deviceId = "my-new-device-" + UUID.randomUUID().toString();
        Device newDevice = Device.createDevice(deviceId, AuthenticationType.SAS);

        try
        {
            log.info("Creating device {}", deviceId);
            registryManager.addDevice(newDevice);
        }
        catch (IOException | IotHubException e)
        {
            log.error("Failed to register new device", e);
            System.exit(-1);
        }

        return deviceId;
    }

    private static void runTwinClientSample(String iotHubHostName, AzureSasCredential credential, String deviceId)
    {
        // DeviceTwin has some configurable options for HTTP read and connect timeouts, as well as for setting proxies.
        // For this sample, the default options will be used though.
        DeviceTwinClientOptions options = DeviceTwinClientOptions.builder().build();

        // This constructor takes in your implementation of AzureSasCredential which allows you to use symmetric key based
        // authentication without giving the client your connection string.
        DeviceTwin twinClient = new DeviceTwin(iotHubHostName, credential, options);

        DeviceTwinDevice newDeviceTwin = new DeviceTwinDevice(deviceId);

        try
        {
            log.info("Getting twin for device {}", deviceId);
            twinClient.getTwin(newDeviceTwin);
        }
        catch (IotHubException | IOException e)
        {
            log.error("Failed to get the twin of the new device", e);
            System.exit(-1);
        }

        log.info("Successfully got the twin for the new device");
        log.info("Device Id: {}", newDeviceTwin.getDeviceId());
        log.info("ETag: {}", newDeviceTwin.getETag());
    }

    private static void runServiceClientSample(String iotHubHostName, AzureSasCredential credential, String deviceId)
    {
        // ServiceClient has some configurable options for setting a custom SSLContext, as well as for setting proxies.
        // For this sample, the default options will be used though.
        ServiceClientOptions options = ServiceClientOptions.builder().build();

        // This constructor takes in your implementation of AzureSasCredential which allows you to use symmetric key based
        // authentication without giving the client your connection string.
        ServiceClient serviceClient =
            new ServiceClient(
                iotHubHostName,
                credential,
                IotHubServiceClientProtocol.AMQPS,
                options);

        String cloudToDeviceMessagePayload = "This is a message sent by an RBAC authenticated service client!";
        Message cloudToDeviceMessage = new Message(cloudToDeviceMessagePayload.getBytes());
        try
        {
            log.info("Sending cloud to device message to the new device");
            serviceClient.send(deviceId, cloudToDeviceMessage);
            log.info("Successfully sent cloud to device message to the new device");
        }
        catch (IOException | IotHubException e)
        {
            log.error("Failed to send a cloud to device message to the new device", e);
            System.exit(-1);
        }

        try
        {
            // FeedbackReceiver will use the same authentication mechanism that the ServiceClient itself uses,
            // so the below APIs are also RBAC authenticated.
            FeedbackReceiver feedbackReceiver = serviceClient.getFeedbackReceiver();

            log.info("Opening feedback receiver to listen for feedback messages");
            feedbackReceiver.open();
            FeedbackBatch feedbackBatch = feedbackReceiver.receive(5 * 1000);

            if (feedbackBatch != null)
            {
                for (FeedbackRecord feedbackRecord : feedbackBatch.getRecords())
                {
                    log.info("Feedback record received for device {} with status {}", feedbackRecord.getDeviceId(), feedbackRecord.getStatusCode());
                }
            }
            else
            {
                log.info("No feedback records were received");
            }

            feedbackReceiver.close();
        }
        catch (IOException | InterruptedException e)
        {
            log.error("Failed to listen for feedback messages", e);
            System.exit(-1);
        }

        try
        {
            // FileUploadNotificationReceiver will use the same authentication mechanism that the ServiceClient itself uses,
            // so the below APIs are also RBAC authenticated.
            FileUploadNotificationReceiver fileUploadNotificationReceiver = serviceClient.getFileUploadNotificationReceiver();

            log.info("Opening file upload notification receiver and listening for file upload notifications");
            fileUploadNotificationReceiver.open();
            FileUploadNotification fileUploadNotification = fileUploadNotificationReceiver.receive(5 * 1000);

            if (fileUploadNotification != null)
            {
                log.info("File upload notification received for device {}\n", fileUploadNotification.getDeviceId());
            }
            else
            {
                log.info("No feedback records were received");
            }

            fileUploadNotificationReceiver.close();
        }
        catch (IOException | InterruptedException e)
        {
            log.error("Failed to listen for file upload notification messages", e);
            System.exit(-1);
        }
    }

    private static void runJobClientSample(String iotHubHostName, AzureSasCredential credential)
    {
        // JobClient has some configurable options for HTTP read and connect timeouts, as well as for setting proxies.
        // For this sample, the default options will be used though.
        JobClientOptions options = JobClientOptions.builder().build();

        // This constructor takes in your implementation of AzureSasCredential which allows you to use symmetric key based
        // authentication without giving the client your connection string.
        JobClient jobClient = new JobClient(iotHubHostName, credential, options);

        try
        {
            log.info("Querying all active jobs for your IoT Hub");
            Query deviceJobQuery = jobClient.queryDeviceJob(SqlQuery.createSqlQuery("*", SqlQuery.FromType.JOBS, null, null).getQuery());
            int queriedJobCount = 0;
            while (jobClient.hasNextJob(deviceJobQuery))
            {
                queriedJobCount++;
                JobResult job = jobClient.getNextJob(deviceJobQuery);
                log.info("Job {} of type {} has status {}", job.getJobId(), job.getJobType(), job.getJobStatus());
            }

            if (queriedJobCount == 0)
            {
                log.info("No active jobs found for your IoT Hub");
            }
        }
        catch (IotHubException | IOException e)
        {
            log.error("Failed to query the jobs for your IoT Hub", e);
            System.exit(-1);
        }
    }

    private static void runDeviceMethodClientSample(String iotHubHostName, AzureSasCredential credential, String deviceId)
    {
        // JobClient has some configurable options for HTTP read and connect timeouts, as well as for setting proxies.
        // For this sample, the default options will be used though.
        DeviceMethodClientOptions options = DeviceMethodClientOptions.builder().build();

        // This constructor takes in your implementation of AzureSasCredential which allows you to use symmetric key based
        // authentication without giving the client your connection string.
        DeviceMethod deviceMethod = new DeviceMethod(iotHubHostName, credential, options);

        try
        {
            log.info("Invoking method on device if it is online");
            deviceMethod.invoke(
                deviceId,
                "someMethodName",
                5L,
                2L,
                "Some method invocation payload");
        }
        catch (IotHubException e)
        {
            if (e.getErrorCodeDescription() == ErrorCodeDescription.DeviceNotOnline)
            {
                log.info("Device was not online, so the method invocation failed.");
            }
            else
            {
                log.error("Failed to invoke a method on your device", e);
                System.exit(-1);
            }
        }
        catch (IOException e)
        {
            log.error("Failed to invoke a method on your device", e);
            System.exit(-1);
        }
    }
}
