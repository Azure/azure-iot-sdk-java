/**
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is
 * regenerated.
 */

package com.microsoft.azure.sdk.iot.digitaltwin.service.generated.implementation;

import retrofit2.Retrofit;
import com.microsoft.azure.sdk.iot.digitaltwin.service.generated.DigitalTwins;
import com.google.common.reflect.TypeToken;
import com.microsoft.azure.sdk.iot.digitaltwin.service.generated.models.DigitalTwinGetDigitalTwinModelHeaders;
import com.microsoft.azure.sdk.iot.digitaltwin.service.generated.models.DigitalTwinGetInterfaceHeaders;
import com.microsoft.azure.sdk.iot.digitaltwin.service.generated.models.DigitalTwinGetInterfacesHeaders;
import com.microsoft.azure.sdk.iot.digitaltwin.service.generated.models.DigitalTwinInterfaces;
import com.microsoft.azure.sdk.iot.digitaltwin.service.generated.models.DigitalTwinInterfacesPatch;
import com.microsoft.azure.sdk.iot.digitaltwin.service.generated.models.DigitalTwinInvokeInterfaceCommandHeaders;
import com.microsoft.azure.sdk.iot.digitaltwin.service.generated.models.DigitalTwinUpdateInterfacesHeaders;
import com.microsoft.rest.RestException;
import com.microsoft.rest.ServiceCallback;
import com.microsoft.rest.ServiceFuture;
import com.microsoft.rest.ServiceResponseWithHeaders;
import com.microsoft.rest.Validator;
import java.io.IOException;
import okhttp3.ResponseBody;
import retrofit2.http.Body;
import retrofit2.http.GET;
import retrofit2.http.Header;
import retrofit2.http.Headers;
import retrofit2.http.PATCH;
import retrofit2.http.Path;
import retrofit2.http.POST;
import retrofit2.http.Query;
import retrofit2.Response;
import rx.functions.Func1;
import rx.Observable;

/**
 * An instance of this class provides access to all the operations defined
 * in DigitalTwins.
 */
public class DigitalTwinsImpl implements DigitalTwins {
    /** The Retrofit service to perform REST calls. */
    private DigitalTwinsService service;
    /** The service client containing this operation class. */
    private IotHubGatewayServiceAPIs20190701PreviewImpl client;

    /**
     * Initializes an instance of DigitalTwins.
     *
     * @param retrofit the Retrofit instance built from a Retrofit Builder.
     * @param client the instance of the service client containing this operation class.
     */
    public DigitalTwinsImpl(Retrofit retrofit, IotHubGatewayServiceAPIs20190701PreviewImpl client) {
        this.service = retrofit.create(DigitalTwinsService.class);
        this.client = client;
    }

    /**
     * The interface defining all the services for DigitalTwins to be
     * used by Retrofit to perform actually REST calls.
     */
    interface DigitalTwinsService {
        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.sdk.iot.digitaltwin.service.generated.DigitalTwins getInterfaces" })
        @GET("digitalTwins/{digitalTwinId}/interfaces")
        Observable<Response<ResponseBody>> getInterfaces(@Path("digitalTwinId") String digitalTwinId, @Query("api-version") String apiVersion);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.sdk.iot.digitaltwin.service.generated.DigitalTwins updateInterfaces" })
        @PATCH("digitalTwins/{digitalTwinId}/interfaces")
        Observable<Response<ResponseBody>> updateInterfaces(@Path("digitalTwinId") String digitalTwinId, @Body DigitalTwinInterfacesPatch interfacesPatchInfo, @Header("If-Match") String ifMatch, @Query("api-version") String apiVersion);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.sdk.iot.digitaltwin.service.generated.DigitalTwins getInterface" })
        @GET("digitalTwins/{digitalTwinId}/interfaces/{interfaceName}")
        Observable<Response<ResponseBody>> getInterface(@Path("digitalTwinId") String digitalTwinId, @Path("interfaceName") String interfaceName, @Query("api-version") String apiVersion);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.sdk.iot.digitaltwin.service.generated.DigitalTwins getDigitalTwinModel" })
        @GET("digitalTwins/models/{modelId}")
        Observable<Response<ResponseBody>> getDigitalTwinModel(@Path("modelId") String modelId, @Query("expand") Boolean expand, @Query("api-version") String apiVersion);

        @Headers({ "Content-Type: application/json; charset=utf-8", "x-ms-logging-context: com.microsoft.azure.sdk.iot.digitaltwin.service.generated.DigitalTwins invokeInterfaceCommand" })
        @POST("digitalTwins/{digitalTwinId}/interfaces/{interfaceName}/commands/{commandName}")
        Observable<Response<ResponseBody>> invokeInterfaceCommand(@Path("digitalTwinId") String digitalTwinId, @Path("interfaceName") String interfaceName, @Path("commandName") String commandName, @Body Object payload, @Query("api-version") String apiVersion, @Query("connectTimeoutInSeconds") Integer connectTimeoutInSeconds, @Query("responseTimeoutInSeconds") Integer responseTimeoutInSeconds);

    }

    /**
     * Gets the list of interfaces.
     *
     * @param digitalTwinId Digital Twin ID. Format of digitalTwinId is DeviceId[~ModuleId]. ModuleId is optional.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the DigitalTwinInterfaces object if successful.
     */
    public DigitalTwinInterfaces getInterfaces(String digitalTwinId) {
        return getInterfacesWithServiceResponseAsync(digitalTwinId).toBlocking().single().body();
    }

    /**
     * Gets the list of interfaces.
     *
     * @param digitalTwinId Digital Twin ID. Format of digitalTwinId is DeviceId[~ModuleId]. ModuleId is optional.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<DigitalTwinInterfaces> getInterfacesAsync(String digitalTwinId, final ServiceCallback<DigitalTwinInterfaces> serviceCallback) {
        return ServiceFuture.fromHeaderResponse(getInterfacesWithServiceResponseAsync(digitalTwinId), serviceCallback);
    }

    /**
     * Gets the list of interfaces.
     *
     * @param digitalTwinId Digital Twin ID. Format of digitalTwinId is DeviceId[~ModuleId]. ModuleId is optional.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the DigitalTwinInterfaces object
     */
    public Observable<DigitalTwinInterfaces> getInterfacesAsync(String digitalTwinId) {
        return getInterfacesWithServiceResponseAsync(digitalTwinId).map(new Func1<ServiceResponseWithHeaders<DigitalTwinInterfaces, DigitalTwinGetInterfacesHeaders>, DigitalTwinInterfaces>() {
            @Override
            public DigitalTwinInterfaces call(ServiceResponseWithHeaders<DigitalTwinInterfaces, DigitalTwinGetInterfacesHeaders> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets the list of interfaces.
     *
     * @param digitalTwinId Digital Twin ID. Format of digitalTwinId is DeviceId[~ModuleId]. ModuleId is optional.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the DigitalTwinInterfaces object
     */
    public Observable<ServiceResponseWithHeaders<DigitalTwinInterfaces, DigitalTwinGetInterfacesHeaders>> getInterfacesWithServiceResponseAsync(String digitalTwinId) {
        if (digitalTwinId == null) {
            throw new IllegalArgumentException("Parameter digitalTwinId is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.getInterfaces(digitalTwinId, this.client.apiVersion())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<DigitalTwinInterfaces, DigitalTwinGetInterfacesHeaders>>>() {
                @Override
                public Observable<ServiceResponseWithHeaders<DigitalTwinInterfaces, DigitalTwinGetInterfacesHeaders>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponseWithHeaders<DigitalTwinInterfaces, DigitalTwinGetInterfacesHeaders> clientResponse = getInterfacesDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponseWithHeaders<DigitalTwinInterfaces, DigitalTwinGetInterfacesHeaders> getInterfacesDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<DigitalTwinInterfaces, RestException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<DigitalTwinInterfaces>() { }.getType())
                .buildWithHeaders(response, DigitalTwinGetInterfacesHeaders.class);
    }

    /**
     * Updates desired properties of multiple interfaces.
                 Example URI: "digitalTwins/{digitalTwinId}/interfaces".
     *
     * @param digitalTwinId Digital Twin ID. Format of digitalTwinId is DeviceId[~ModuleId]. ModuleId is optional.
     * @param interfacesPatchInfo Multiple interfaces desired properties to update.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the DigitalTwinInterfaces object if successful.
     */
    public DigitalTwinInterfaces updateInterfaces(String digitalTwinId, DigitalTwinInterfacesPatch interfacesPatchInfo) {
        return updateInterfacesWithServiceResponseAsync(digitalTwinId, interfacesPatchInfo).toBlocking().single().body();
    }

    /**
     * Updates desired properties of multiple interfaces.
                 Example URI: "digitalTwins/{digitalTwinId}/interfaces".
     *
     * @param digitalTwinId Digital Twin ID. Format of digitalTwinId is DeviceId[~ModuleId]. ModuleId is optional.
     * @param interfacesPatchInfo Multiple interfaces desired properties to update.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<DigitalTwinInterfaces> updateInterfacesAsync(String digitalTwinId, DigitalTwinInterfacesPatch interfacesPatchInfo, final ServiceCallback<DigitalTwinInterfaces> serviceCallback) {
        return ServiceFuture.fromHeaderResponse(updateInterfacesWithServiceResponseAsync(digitalTwinId, interfacesPatchInfo), serviceCallback);
    }

    /**
     * Updates desired properties of multiple interfaces.
                 Example URI: "digitalTwins/{digitalTwinId}/interfaces".
     *
     * @param digitalTwinId Digital Twin ID. Format of digitalTwinId is DeviceId[~ModuleId]. ModuleId is optional.
     * @param interfacesPatchInfo Multiple interfaces desired properties to update.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the DigitalTwinInterfaces object
     */
    public Observable<DigitalTwinInterfaces> updateInterfacesAsync(String digitalTwinId, DigitalTwinInterfacesPatch interfacesPatchInfo) {
        return updateInterfacesWithServiceResponseAsync(digitalTwinId, interfacesPatchInfo).map(new Func1<ServiceResponseWithHeaders<DigitalTwinInterfaces, DigitalTwinUpdateInterfacesHeaders>, DigitalTwinInterfaces>() {
            @Override
            public DigitalTwinInterfaces call(ServiceResponseWithHeaders<DigitalTwinInterfaces, DigitalTwinUpdateInterfacesHeaders> response) {
                return response.body();
            }
        });
    }

    /**
     * Updates desired properties of multiple interfaces.
                 Example URI: "digitalTwins/{digitalTwinId}/interfaces".
     *
     * @param digitalTwinId Digital Twin ID. Format of digitalTwinId is DeviceId[~ModuleId]. ModuleId is optional.
     * @param interfacesPatchInfo Multiple interfaces desired properties to update.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the DigitalTwinInterfaces object
     */
    public Observable<ServiceResponseWithHeaders<DigitalTwinInterfaces, DigitalTwinUpdateInterfacesHeaders>> updateInterfacesWithServiceResponseAsync(String digitalTwinId, DigitalTwinInterfacesPatch interfacesPatchInfo) {
        if (digitalTwinId == null) {
            throw new IllegalArgumentException("Parameter digitalTwinId is required and cannot be null.");
        }
        if (interfacesPatchInfo == null) {
            throw new IllegalArgumentException("Parameter interfacesPatchInfo is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(interfacesPatchInfo);
        final String ifMatch = null;
        return service.updateInterfaces(digitalTwinId, interfacesPatchInfo, ifMatch, this.client.apiVersion())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<DigitalTwinInterfaces, DigitalTwinUpdateInterfacesHeaders>>>() {
                @Override
                public Observable<ServiceResponseWithHeaders<DigitalTwinInterfaces, DigitalTwinUpdateInterfacesHeaders>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponseWithHeaders<DigitalTwinInterfaces, DigitalTwinUpdateInterfacesHeaders> clientResponse = updateInterfacesDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Updates desired properties of multiple interfaces.
                 Example URI: "digitalTwins/{digitalTwinId}/interfaces".
     *
     * @param digitalTwinId Digital Twin ID. Format of digitalTwinId is DeviceId[~ModuleId]. ModuleId is optional.
     * @param interfacesPatchInfo Multiple interfaces desired properties to update.
     * @param ifMatch the String value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the DigitalTwinInterfaces object if successful.
     */
    public DigitalTwinInterfaces updateInterfaces(String digitalTwinId, DigitalTwinInterfacesPatch interfacesPatchInfo, String ifMatch) {
        return updateInterfacesWithServiceResponseAsync(digitalTwinId, interfacesPatchInfo, ifMatch).toBlocking().single().body();
    }

    /**
     * Updates desired properties of multiple interfaces.
                 Example URI: "digitalTwins/{digitalTwinId}/interfaces".
     *
     * @param digitalTwinId Digital Twin ID. Format of digitalTwinId is DeviceId[~ModuleId]. ModuleId is optional.
     * @param interfacesPatchInfo Multiple interfaces desired properties to update.
     * @param ifMatch the String value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<DigitalTwinInterfaces> updateInterfacesAsync(String digitalTwinId, DigitalTwinInterfacesPatch interfacesPatchInfo, String ifMatch, final ServiceCallback<DigitalTwinInterfaces> serviceCallback) {
        return ServiceFuture.fromHeaderResponse(updateInterfacesWithServiceResponseAsync(digitalTwinId, interfacesPatchInfo, ifMatch), serviceCallback);
    }

    /**
     * Updates desired properties of multiple interfaces.
                 Example URI: "digitalTwins/{digitalTwinId}/interfaces".
     *
     * @param digitalTwinId Digital Twin ID. Format of digitalTwinId is DeviceId[~ModuleId]. ModuleId is optional.
     * @param interfacesPatchInfo Multiple interfaces desired properties to update.
     * @param ifMatch the String value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the DigitalTwinInterfaces object
     */
    public Observable<DigitalTwinInterfaces> updateInterfacesAsync(String digitalTwinId, DigitalTwinInterfacesPatch interfacesPatchInfo, String ifMatch) {
        return updateInterfacesWithServiceResponseAsync(digitalTwinId, interfacesPatchInfo, ifMatch).map(new Func1<ServiceResponseWithHeaders<DigitalTwinInterfaces, DigitalTwinUpdateInterfacesHeaders>, DigitalTwinInterfaces>() {
            @Override
            public DigitalTwinInterfaces call(ServiceResponseWithHeaders<DigitalTwinInterfaces, DigitalTwinUpdateInterfacesHeaders> response) {
                return response.body();
            }
        });
    }

    /**
     * Updates desired properties of multiple interfaces.
                 Example URI: "digitalTwins/{digitalTwinId}/interfaces".
     *
     * @param digitalTwinId Digital Twin ID. Format of digitalTwinId is DeviceId[~ModuleId]. ModuleId is optional.
     * @param interfacesPatchInfo Multiple interfaces desired properties to update.
     * @param ifMatch the String value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the DigitalTwinInterfaces object
     */
    public Observable<ServiceResponseWithHeaders<DigitalTwinInterfaces, DigitalTwinUpdateInterfacesHeaders>> updateInterfacesWithServiceResponseAsync(String digitalTwinId, DigitalTwinInterfacesPatch interfacesPatchInfo, String ifMatch) {
        if (digitalTwinId == null) {
            throw new IllegalArgumentException("Parameter digitalTwinId is required and cannot be null.");
        }
        if (interfacesPatchInfo == null) {
            throw new IllegalArgumentException("Parameter interfacesPatchInfo is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        Validator.validate(interfacesPatchInfo);
        return service.updateInterfaces(digitalTwinId, interfacesPatchInfo, ifMatch, this.client.apiVersion())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<DigitalTwinInterfaces, DigitalTwinUpdateInterfacesHeaders>>>() {
                @Override
                public Observable<ServiceResponseWithHeaders<DigitalTwinInterfaces, DigitalTwinUpdateInterfacesHeaders>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponseWithHeaders<DigitalTwinInterfaces, DigitalTwinUpdateInterfacesHeaders> clientResponse = updateInterfacesDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponseWithHeaders<DigitalTwinInterfaces, DigitalTwinUpdateInterfacesHeaders> updateInterfacesDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<DigitalTwinInterfaces, RestException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<DigitalTwinInterfaces>() { }.getType())
                .buildWithHeaders(response, DigitalTwinUpdateInterfacesHeaders.class);
    }

    /**
     * Gets the interface of given interfaceId.
                 Example URI: "digitalTwins/{digitalTwinId}/interfaces/{interfaceName}".
     *
     * @param digitalTwinId Digital Twin ID. Format of digitalTwinId is DeviceId[~ModuleId]. ModuleId is optional.
     * @param interfaceName The interface name.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the DigitalTwinInterfaces object if successful.
     */
    public DigitalTwinInterfaces getInterface(String digitalTwinId, String interfaceName) {
        return getInterfaceWithServiceResponseAsync(digitalTwinId, interfaceName).toBlocking().single().body();
    }

    /**
     * Gets the interface of given interfaceId.
                 Example URI: "digitalTwins/{digitalTwinId}/interfaces/{interfaceName}".
     *
     * @param digitalTwinId Digital Twin ID. Format of digitalTwinId is DeviceId[~ModuleId]. ModuleId is optional.
     * @param interfaceName The interface name.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<DigitalTwinInterfaces> getInterfaceAsync(String digitalTwinId, String interfaceName, final ServiceCallback<DigitalTwinInterfaces> serviceCallback) {
        return ServiceFuture.fromHeaderResponse(getInterfaceWithServiceResponseAsync(digitalTwinId, interfaceName), serviceCallback);
    }

    /**
     * Gets the interface of given interfaceId.
                 Example URI: "digitalTwins/{digitalTwinId}/interfaces/{interfaceName}".
     *
     * @param digitalTwinId Digital Twin ID. Format of digitalTwinId is DeviceId[~ModuleId]. ModuleId is optional.
     * @param interfaceName The interface name.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the DigitalTwinInterfaces object
     */
    public Observable<DigitalTwinInterfaces> getInterfaceAsync(String digitalTwinId, String interfaceName) {
        return getInterfaceWithServiceResponseAsync(digitalTwinId, interfaceName).map(new Func1<ServiceResponseWithHeaders<DigitalTwinInterfaces, DigitalTwinGetInterfaceHeaders>, DigitalTwinInterfaces>() {
            @Override
            public DigitalTwinInterfaces call(ServiceResponseWithHeaders<DigitalTwinInterfaces, DigitalTwinGetInterfaceHeaders> response) {
                return response.body();
            }
        });
    }

    /**
     * Gets the interface of given interfaceId.
                 Example URI: "digitalTwins/{digitalTwinId}/interfaces/{interfaceName}".
     *
     * @param digitalTwinId Digital Twin ID. Format of digitalTwinId is DeviceId[~ModuleId]. ModuleId is optional.
     * @param interfaceName The interface name.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the DigitalTwinInterfaces object
     */
    public Observable<ServiceResponseWithHeaders<DigitalTwinInterfaces, DigitalTwinGetInterfaceHeaders>> getInterfaceWithServiceResponseAsync(String digitalTwinId, String interfaceName) {
        if (digitalTwinId == null) {
            throw new IllegalArgumentException("Parameter digitalTwinId is required and cannot be null.");
        }
        if (interfaceName == null) {
            throw new IllegalArgumentException("Parameter interfaceName is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.getInterface(digitalTwinId, interfaceName, this.client.apiVersion())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<DigitalTwinInterfaces, DigitalTwinGetInterfaceHeaders>>>() {
                @Override
                public Observable<ServiceResponseWithHeaders<DigitalTwinInterfaces, DigitalTwinGetInterfaceHeaders>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponseWithHeaders<DigitalTwinInterfaces, DigitalTwinGetInterfaceHeaders> clientResponse = getInterfaceDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponseWithHeaders<DigitalTwinInterfaces, DigitalTwinGetInterfaceHeaders> getInterfaceDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<DigitalTwinInterfaces, RestException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<DigitalTwinInterfaces>() { }.getType())
                .buildWithHeaders(response, DigitalTwinGetInterfaceHeaders.class);
    }

    /**
     * Returns a DigitalTwin model definition for the given id.
     If "expand" is present in the query parameters and id is for a device capability model then it returns
     the capability metamodel with expanded interface definitions.
     *
     * @param modelId Model id Ex: &lt;example&gt;urn:contoso:TemperatureSensor:1&lt;/example&gt;
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object getDigitalTwinModel(String modelId) {
        return getDigitalTwinModelWithServiceResponseAsync(modelId).toBlocking().single().body();
    }

    /**
     * Returns a DigitalTwin model definition for the given id.
     If "expand" is present in the query parameters and id is for a device capability model then it returns
     the capability metamodel with expanded interface definitions.
     *
     * @param modelId Model id Ex: &lt;example&gt;urn:contoso:TemperatureSensor:1&lt;/example&gt;
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> getDigitalTwinModelAsync(String modelId, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromHeaderResponse(getDigitalTwinModelWithServiceResponseAsync(modelId), serviceCallback);
    }

    /**
     * Returns a DigitalTwin model definition for the given id.
     If "expand" is present in the query parameters and id is for a device capability model then it returns
     the capability metamodel with expanded interface definitions.
     *
     * @param modelId Model id Ex: &lt;example&gt;urn:contoso:TemperatureSensor:1&lt;/example&gt;
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> getDigitalTwinModelAsync(String modelId) {
        return getDigitalTwinModelWithServiceResponseAsync(modelId).map(new Func1<ServiceResponseWithHeaders<Object, DigitalTwinGetDigitalTwinModelHeaders>, Object>() {
            @Override
            public Object call(ServiceResponseWithHeaders<Object, DigitalTwinGetDigitalTwinModelHeaders> response) {
                return response.body();
            }
        });
    }

    /**
     * Returns a DigitalTwin model definition for the given id.
     If "expand" is present in the query parameters and id is for a device capability model then it returns
     the capability metamodel with expanded interface definitions.
     *
     * @param modelId Model id Ex: &lt;example&gt;urn:contoso:TemperatureSensor:1&lt;/example&gt;
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponseWithHeaders<Object, DigitalTwinGetDigitalTwinModelHeaders>> getDigitalTwinModelWithServiceResponseAsync(String modelId) {
        if (modelId == null) {
            throw new IllegalArgumentException("Parameter modelId is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        final Boolean expand = null;
        return service.getDigitalTwinModel(modelId, expand, this.client.apiVersion())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<Object, DigitalTwinGetDigitalTwinModelHeaders>>>() {
                @Override
                public Observable<ServiceResponseWithHeaders<Object, DigitalTwinGetDigitalTwinModelHeaders>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponseWithHeaders<Object, DigitalTwinGetDigitalTwinModelHeaders> clientResponse = getDigitalTwinModelDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Returns a DigitalTwin model definition for the given id.
     If "expand" is present in the query parameters and id is for a device capability model then it returns
     the capability metamodel with expanded interface definitions.
     *
     * @param modelId Model id Ex: &lt;example&gt;urn:contoso:TemperatureSensor:1&lt;/example&gt;
     * @param expand Indicates whether to expand the device capability model's interface definitions inline or not.
     This query parameter ONLY applies to Capability model.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object getDigitalTwinModel(String modelId, Boolean expand) {
        return getDigitalTwinModelWithServiceResponseAsync(modelId, expand).toBlocking().single().body();
    }

    /**
     * Returns a DigitalTwin model definition for the given id.
     If "expand" is present in the query parameters and id is for a device capability model then it returns
     the capability metamodel with expanded interface definitions.
     *
     * @param modelId Model id Ex: &lt;example&gt;urn:contoso:TemperatureSensor:1&lt;/example&gt;
     * @param expand Indicates whether to expand the device capability model's interface definitions inline or not.
     This query parameter ONLY applies to Capability model.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> getDigitalTwinModelAsync(String modelId, Boolean expand, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromHeaderResponse(getDigitalTwinModelWithServiceResponseAsync(modelId, expand), serviceCallback);
    }

    /**
     * Returns a DigitalTwin model definition for the given id.
     If "expand" is present in the query parameters and id is for a device capability model then it returns
     the capability metamodel with expanded interface definitions.
     *
     * @param modelId Model id Ex: &lt;example&gt;urn:contoso:TemperatureSensor:1&lt;/example&gt;
     * @param expand Indicates whether to expand the device capability model's interface definitions inline or not.
     This query parameter ONLY applies to Capability model.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> getDigitalTwinModelAsync(String modelId, Boolean expand) {
        return getDigitalTwinModelWithServiceResponseAsync(modelId, expand).map(new Func1<ServiceResponseWithHeaders<Object, DigitalTwinGetDigitalTwinModelHeaders>, Object>() {
            @Override
            public Object call(ServiceResponseWithHeaders<Object, DigitalTwinGetDigitalTwinModelHeaders> response) {
                return response.body();
            }
        });
    }

    /**
     * Returns a DigitalTwin model definition for the given id.
     If "expand" is present in the query parameters and id is for a device capability model then it returns
     the capability metamodel with expanded interface definitions.
     *
     * @param modelId Model id Ex: &lt;example&gt;urn:contoso:TemperatureSensor:1&lt;/example&gt;
     * @param expand Indicates whether to expand the device capability model's interface definitions inline or not.
     This query parameter ONLY applies to Capability model.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponseWithHeaders<Object, DigitalTwinGetDigitalTwinModelHeaders>> getDigitalTwinModelWithServiceResponseAsync(String modelId, Boolean expand) {
        if (modelId == null) {
            throw new IllegalArgumentException("Parameter modelId is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.getDigitalTwinModel(modelId, expand, this.client.apiVersion())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<Object, DigitalTwinGetDigitalTwinModelHeaders>>>() {
                @Override
                public Observable<ServiceResponseWithHeaders<Object, DigitalTwinGetDigitalTwinModelHeaders>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponseWithHeaders<Object, DigitalTwinGetDigitalTwinModelHeaders> clientResponse = getDigitalTwinModelDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponseWithHeaders<Object, DigitalTwinGetDigitalTwinModelHeaders> getDigitalTwinModelDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<Object, RestException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<Object>() { }.getType())
                .buildWithHeaders(response, DigitalTwinGetDigitalTwinModelHeaders.class);
    }

    /**
     * Invoke a digital twin interface command.
     * Invoke a digital twin interface command.
     *
     * @param digitalTwinId the String value
     * @param interfaceName the String value
     * @param commandName the String value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object invokeInterfaceCommand(String digitalTwinId, String interfaceName, String commandName) {
        return invokeInterfaceCommandWithServiceResponseAsync(digitalTwinId, interfaceName, commandName).toBlocking().single().body();
    }

    /**
     * Invoke a digital twin interface command.
     * Invoke a digital twin interface command.
     *
     * @param digitalTwinId the String value
     * @param interfaceName the String value
     * @param commandName the String value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> invokeInterfaceCommandAsync(String digitalTwinId, String interfaceName, String commandName, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromHeaderResponse(invokeInterfaceCommandWithServiceResponseAsync(digitalTwinId, interfaceName, commandName), serviceCallback);
    }

    /**
     * Invoke a digital twin interface command.
     * Invoke a digital twin interface command.
     *
     * @param digitalTwinId the String value
     * @param interfaceName the String value
     * @param commandName the String value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> invokeInterfaceCommandAsync(String digitalTwinId, String interfaceName, String commandName) {
        return invokeInterfaceCommandWithServiceResponseAsync(digitalTwinId, interfaceName, commandName).map(new Func1<ServiceResponseWithHeaders<Object, DigitalTwinInvokeInterfaceCommandHeaders>, Object>() {
            @Override
            public Object call(ServiceResponseWithHeaders<Object, DigitalTwinInvokeInterfaceCommandHeaders> response) {
                return response.body();
            }
        });
    }

    /**
     * Invoke a digital twin interface command.
     * Invoke a digital twin interface command.
     *
     * @param digitalTwinId the String value
     * @param interfaceName the String value
     * @param commandName the String value
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponseWithHeaders<Object, DigitalTwinInvokeInterfaceCommandHeaders>> invokeInterfaceCommandWithServiceResponseAsync(String digitalTwinId, String interfaceName, String commandName) {
        if (digitalTwinId == null) {
            throw new IllegalArgumentException("Parameter digitalTwinId is required and cannot be null.");
        }
        if (interfaceName == null) {
            throw new IllegalArgumentException("Parameter interfaceName is required and cannot be null.");
        }
        if (commandName == null) {
            throw new IllegalArgumentException("Parameter commandName is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        final Object payload = null;
        final Integer connectTimeoutInSeconds = null;
        final Integer responseTimeoutInSeconds = null;
        return service.invokeInterfaceCommand(digitalTwinId, interfaceName, commandName, payload, this.client.apiVersion(), connectTimeoutInSeconds, responseTimeoutInSeconds)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<Object, DigitalTwinInvokeInterfaceCommandHeaders>>>() {
                @Override
                public Observable<ServiceResponseWithHeaders<Object, DigitalTwinInvokeInterfaceCommandHeaders>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponseWithHeaders<Object, DigitalTwinInvokeInterfaceCommandHeaders> clientResponse = invokeInterfaceCommandDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Invoke a digital twin interface command.
     * Invoke a digital twin interface command.
     *
     * @param digitalTwinId the String value
     * @param interfaceName the String value
     * @param commandName the String value
     * @param payload the Object value
     * @param connectTimeoutInSeconds Connect timeout in seconds.
     * @param responseTimeoutInSeconds Response timeout in seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @throws RestException thrown if the request is rejected by server
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent
     * @return the Object object if successful.
     */
    public Object invokeInterfaceCommand(String digitalTwinId, String interfaceName, String commandName, Object payload, Integer connectTimeoutInSeconds, Integer responseTimeoutInSeconds) {
        return invokeInterfaceCommandWithServiceResponseAsync(digitalTwinId, interfaceName, commandName, payload, connectTimeoutInSeconds, responseTimeoutInSeconds).toBlocking().single().body();
    }

    /**
     * Invoke a digital twin interface command.
     * Invoke a digital twin interface command.
     *
     * @param digitalTwinId the String value
     * @param interfaceName the String value
     * @param commandName the String value
     * @param payload the Object value
     * @param connectTimeoutInSeconds Connect timeout in seconds.
     * @param responseTimeoutInSeconds Response timeout in seconds.
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the {@link ServiceFuture} object
     */
    public ServiceFuture<Object> invokeInterfaceCommandAsync(String digitalTwinId, String interfaceName, String commandName, Object payload, Integer connectTimeoutInSeconds, Integer responseTimeoutInSeconds, final ServiceCallback<Object> serviceCallback) {
        return ServiceFuture.fromHeaderResponse(invokeInterfaceCommandWithServiceResponseAsync(digitalTwinId, interfaceName, commandName, payload, connectTimeoutInSeconds, responseTimeoutInSeconds), serviceCallback);
    }

    /**
     * Invoke a digital twin interface command.
     * Invoke a digital twin interface command.
     *
     * @param digitalTwinId the String value
     * @param interfaceName the String value
     * @param commandName the String value
     * @param payload the Object value
     * @param connectTimeoutInSeconds Connect timeout in seconds.
     * @param responseTimeoutInSeconds Response timeout in seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<Object> invokeInterfaceCommandAsync(String digitalTwinId, String interfaceName, String commandName, Object payload, Integer connectTimeoutInSeconds, Integer responseTimeoutInSeconds) {
        return invokeInterfaceCommandWithServiceResponseAsync(digitalTwinId, interfaceName, commandName, payload, connectTimeoutInSeconds, responseTimeoutInSeconds).map(new Func1<ServiceResponseWithHeaders<Object, DigitalTwinInvokeInterfaceCommandHeaders>, Object>() {
            @Override
            public Object call(ServiceResponseWithHeaders<Object, DigitalTwinInvokeInterfaceCommandHeaders> response) {
                return response.body();
            }
        });
    }

    /**
     * Invoke a digital twin interface command.
     * Invoke a digital twin interface command.
     *
     * @param digitalTwinId the String value
     * @param interfaceName the String value
     * @param commandName the String value
     * @param payload the Object value
     * @param connectTimeoutInSeconds Connect timeout in seconds.
     * @param responseTimeoutInSeconds Response timeout in seconds.
     * @throws IllegalArgumentException thrown if parameters fail the validation
     * @return the observable to the Object object
     */
    public Observable<ServiceResponseWithHeaders<Object, DigitalTwinInvokeInterfaceCommandHeaders>> invokeInterfaceCommandWithServiceResponseAsync(String digitalTwinId, String interfaceName, String commandName, Object payload, Integer connectTimeoutInSeconds, Integer responseTimeoutInSeconds) {
        if (digitalTwinId == null) {
            throw new IllegalArgumentException("Parameter digitalTwinId is required and cannot be null.");
        }
        if (interfaceName == null) {
            throw new IllegalArgumentException("Parameter interfaceName is required and cannot be null.");
        }
        if (commandName == null) {
            throw new IllegalArgumentException("Parameter commandName is required and cannot be null.");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException("Parameter this.client.apiVersion() is required and cannot be null.");
        }
        return service.invokeInterfaceCommand(digitalTwinId, interfaceName, commandName, payload, this.client.apiVersion(), connectTimeoutInSeconds, responseTimeoutInSeconds)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponseWithHeaders<Object, DigitalTwinInvokeInterfaceCommandHeaders>>>() {
                @Override
                public Observable<ServiceResponseWithHeaders<Object, DigitalTwinInvokeInterfaceCommandHeaders>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponseWithHeaders<Object, DigitalTwinInvokeInterfaceCommandHeaders> clientResponse = invokeInterfaceCommandDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponseWithHeaders<Object, DigitalTwinInvokeInterfaceCommandHeaders> invokeInterfaceCommandDelegate(Response<ResponseBody> response) throws RestException, IOException, IllegalArgumentException {
        return this.client.restClient().responseBuilderFactory().<Object, RestException>newInstance(this.client.serializerAdapter())
                .register(200, new TypeToken<Object>() { }.getType())
                .buildWithHeaders(response, DigitalTwinInvokeInterfaceCommandHeaders.class);
    }

}
